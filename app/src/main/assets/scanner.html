<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PDF Document Scanner</title>
    <!-- We link to online versions of the libraries for simplicity -->
    <script src="./opencv.js" async></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* --- 1. Global Styles & Color Palette (Your Theme) --- */
        :root {
            --color-bg-main: #f0f0f0;
            --color-bg-element: #E1F5FE;
            --color-primary-accent: #007BFF;
            --color-accent-shade: #6f42c1;
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-border: rgba(0, 0, 0, 0.1);
            --color-hover-bg: rgba(0, 123, 255, 0.1);
            --font-family: 'Segoe UI', 'Roboto', system-ui, sans-serif;
            --border-radius: 12px;
        }

        /* --- 2. Base & Layout Styles --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            font-family: var(--font-family);
            background-color: var(--color-bg-main);
            color: var(--color-text-primary);
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent; /* Disable tap highlight on Android */
        }
        .container { padding: 20px; max-width: 100%; margin: 0 auto; }
        h1 { color: var(--color-text-primary); text-align: center; margin-bottom: 24px; }

        /* --- 3. Buttons & Controls --- */
        .btn {
            display: block; width: 100%; padding: 15px 20px; font-size: 16px;
            font-weight: 600; border: none; border-radius: var(--border-radius);
            cursor: pointer; transition: all 0.2s ease-in-out; text-align: center;
            margin-bottom: 12px;
        }
        .btn-primary { background-color: var(--color-primary-accent); color: white; }
        .btn-primary:active { background-color: #0056b3; }
        .btn-primary:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        .btn-secondary { background-color: var(--color-accent-shade); color: white; }
        .btn-secondary:active { background-color: #5a3d90; }
        .btn-danger { background-color: #dc3545; color: white; }

        /* --- 4. Page Thumbnails --- */
        #pages-container {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .page-thumbnail {
            position: relative; border: 2px solid var(--color-border);
            border-radius: var(--border-radius); overflow: hidden;
            background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .page-thumbnail img { width: 100%; height: auto; display: block; }
        .page-thumbnail .delete-btn {
            position: absolute; top: 5px; right: 5px; width: 28px; height: 28px;
            background-color: rgba(220, 53, 69, 0.9); color: white; border: none;
            border-radius: 50%; font-size: 16px; font-weight: bold;
            line-height: 28px; text-align: center; cursor: pointer;
        }

        /* --- 5. Modal Styles (for Scanner & Preview) --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); display: none;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background-color: var(--color-bg-element); padding: 20px;
            border-radius: var(--border-radius); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 95vw; max-width: 500px; display: flex; flex-direction: column;
        }
        #scanner-view {
            position: relative; width: 100%; padding-top: 133.33%; /* 4:3 Aspect Ratio */
            background-color: black; border-radius: var(--border-radius); overflow: hidden;
        }
        #scanner-view video, #scanner-view canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }
        .modal-controls { margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        #preview-canvas { width: 100%; height: auto; border-radius: var(--border-radius); border: 1px solid var(--color-border); }
        .filter-controls { display: flex; justify-content: space-around; margin-bottom: 15px; }
        .filter-controls button {
            flex: 1; margin: 0 5px; padding: 10px; font-size: 14px;
            background-color: #f8f9fa; color: var(--color-text-primary);
            border: 1px solid var(--color-border);
        }
        .filter-controls button.active {
            background-color: var(--color-primary-accent); color: white;
            border-color: var(--color-primary-accent);
        }

        /* --- 6. Loading Spinner --- */
        .loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.8); display: none;
            justify-content: center; align-items: center; z-index: 2000;
        }
        .loader {
            border: 8px solid var(--color-bg-main);
            border-top: 8px solid var(--color-primary-accent);
            border-radius: 50%; width: 60px; height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Main App UI -->
    <div class="container">
        <h1>Document Scanner</h1>
        <button id="start-scan-btn" class="btn btn-primary">Start Scanning</button>
        <button id="generate-pdf-btn" class="btn btn-secondary" disabled>Generate PDF & Save</button>
        <div id="pages-container"></div>
    </div>

    <!-- Scanner Modal -->
    <div id="scanner-modal" class="modal">
        <div class="modal-content">
            <div id="scanner-view"><video id="video-feed" playsinline></video><canvas id="overlay-canvas"></canvas></div>
            <div class="modal-controls">
                <button id="capture-btn" class="btn btn-primary">Capture</button>
                <button id="close-scanner-btn" class="btn btn-danger">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Preview & Edit Modal -->
    <div id="preview-modal" class="modal">
        <div class="modal-content">
            <canvas id="preview-canvas"></canvas>
            <div class="modal-controls">
                <div class="filter-controls">
                    <button class="filter-btn active" data-filter="color">Color</button>
                    <button class="filter-btn" data-filter="grayscale">Gray</button>
                    <button class="filter-btn" data-filter="bw">B&W</button>
                </div>
                <button id="add-page-btn" class="btn btn-primary">Add to Document</button>
                <button id="discard-page-btn" class="btn btn-danger">Discard</button>
            </div>
        </div>
    </div>

    <!-- Loader -->
    <div id="loader" class="loader-overlay"><div class="loader"></div></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const startScanBtn = document.getElementById('start-scan-btn');
        const generatePdfBtn = document.getElementById('generate-pdf-btn');
        const pagesContainer = document.getElementById('pages-container');
        const scannerModal = document.getElementById('scanner-modal');
        const videoFeed = document.getElementById('video-feed');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const captureBtn = document.getElementById('capture-btn');
        const closeScannerBtn = document.getElementById('close-scanner-btn');
        const previewModal = document.getElementById('preview-modal');
        const previewCanvas = document.getElementById('preview-canvas');
        const filterBtns = document.querySelectorAll('.filter-btn');
        const addPageBtn = document.getElementById('add-page-btn');
        const discardPageBtn = document.getElementById('discard-page-btn');
        const loader = document.getElementById('loader');

        let stream, cvReady = false, processing = false, detectedCorners, originalCapturedMat;
        let scannedPages = [];
        const { jsPDF } = window.jspdf;

        const onCvReady = () => {
            cvReady = true;
            console.log('OpenCV.js is ready.');
            startScanBtn.disabled = false;
            startScanBtn.textContent = 'Start Scanning';
        };

        if (typeof cv !== 'undefined') onCvReady();
        else document.querySelector('script[src*="opencv.js"]').onload = onCvReady;

        const showLoader = (show) => { loader.style.display = show ? 'flex' : 'none'; };
        const updatePdfButtonState = () => { generatePdfBtn.disabled = scannedPages.length === 0; };
        
        const startCamera = async () => {
            if (!cvReady) { alert('Vision library not loaded. Please wait.'); return; }
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false });
                videoFeed.srcObject = stream;
                await videoFeed.play();
                scannerModal.style.display = 'flex';
                processing = true;
                requestAnimationFrame(processVideoFrame);
            } catch (err) {
                console.error("Error accessing camera: ", err);
                alert('Could not access camera. Please ensure permissions are granted in app settings.');
            }
        };

        const stopCamera = () => {
            processing = false;
            if (stream) stream.getTracks().forEach(track => track.stop());
            scannerModal.style.display = 'none';
        };

        const processVideoFrame = () => {
            if (!processing) return;
            const oCtx = overlayCanvas.getContext('2d');
            overlayCanvas.width = videoFeed.videoWidth;
            overlayCanvas.height = videoFeed.videoHeight;
            oCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            try {
                const src = new cv.Mat(videoFeed.videoHeight, videoFeed.videoWidth, cv.CV_8UC4);
                const cap = new cv.VideoCapture(videoFeed);
                cap.read(src);
                const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                const blurred = new cv.Mat(); cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                const edged = new cv.Mat(); cv.Canny(blurred, edged, 75, 200);
                const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
                cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
                let maxArea = 0, biggestContour = null;
                for (let i = 0; i < contours.size(); ++i) {
                    const cnt = contours.get(i);
                    const area = cv.contourArea(cnt);
                    if (area > 5000) {
                        const peri = cv.arcLength(cnt, true);
                        const approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                        if (approx.rows === 4 && area > maxArea) {
                            maxArea = area;
                            if (biggestContour) biggestContour.delete();
                            biggestContour = approx;
                        } else { approx.delete(); }
                    }
                    cnt.delete();
                }
                if (biggestContour) {
                    detectedCorners = Array.from(biggestContour.data32S).reduce((acc, val, i) => {
                        if (i % 2 === 0) acc.push({ x: val });
                        else acc[acc.length - 1].y = val;
                        return acc;
                    }, []);
                    detectedCorners.sort((a, b) => a.y - b.y);
                    const top = detectedCorners.slice(0, 2).sort((a, b) => a.x - b.x);
                    const bottom = detectedCorners.slice(2, 4).sort((a, b) => a.x - b.x);
                    detectedCorners = [top[0], top[1], bottom[1], bottom[0]];
                    oCtx.strokeStyle = '#00ff00'; oCtx.lineWidth = 5; oCtx.beginPath();
                    oCtx.moveTo(detectedCorners[0].x, detectedCorners[0].y);
                    for (let i = 1; i < 4; i++) oCtx.lineTo(detectedCorners[i].x, detectedCorners[i].y);
                    oCtx.closePath(); oCtx.stroke();
                    biggestContour.delete();
                } else { detectedCorners = null; }
                src.delete(); gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
            } catch (e) { console.error('OpenCV processing error:', e); }
            if (processing) requestAnimationFrame(processVideoFrame);
        };
        
        const captureAndProcess = () => {
            if (!detectedCorners) { alert('No document detected. Please try to get a clearer view.'); return; }
            showLoader(true);
            setTimeout(() => {
                const cap = new cv.VideoCapture(videoFeed);
                originalCapturedMat = new cv.Mat(videoFeed.videoHeight, videoFeed.videoWidth, cv.CV_8UC4);
                cap.read(originalCapturedMat);
                applyFilter('color'); // Apply default color filter to show preview
                stopCamera();
                previewModal.style.display = 'flex';
                filterBtns.forEach(btn => btn.classList.remove('active'));
                document.querySelector('.filter-btn[data-filter="color"]').classList.add('active');
                showLoader(false);
            }, 100);
        };

        const applyFilter = (filter) => {
            if (!originalCapturedMat || originalCapturedMat.isDeleted() || !detectedCorners) return;
            showLoader(true);
            setTimeout(() => {
                const srcCorners = cv.matFromArray(4, 1, cv.CV_32FC2, detectedCorners.flatMap(p => [p.x, p.y]));
                const w = Math.max(Math.hypot(detectedCorners[2].x - detectedCorners[3].x, detectedCorners[2].y - detectedCorners[3].y), Math.hypot(detectedCorners[1].x - detectedCorners[0].x, detectedCorners[1].y - detectedCorners[0].y));
                const h = Math.max(Math.hypot(detectedCorners[1].x - detectedCorners[2].x, detectedCorners[1].y - detectedCorners[2].y), Math.hypot(detectedCorners[0].x - detectedCorners[3].x, detectedCorners[0].y - detectedCorners[3].y));
                const destCorners = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, w, 0, w, h, 0, h]);
                const M = cv.getPerspectiveTransform(srcCorners, destCorners);
                const warped = new cv.Mat();
                cv.warpPerspective(originalCapturedMat, warped, M, new cv.Size(w, h));
                
                let finalMat = new cv.Mat();
                if (filter === 'grayscale') { cv.cvtColor(warped, finalMat, cv.COLOR_RGBA2GRAY); }
                else if (filter === 'bw') {
                    let gray = new cv.Mat();
                    cv.cvtColor(warped, gray, cv.COLOR_RGBA2GRAY);
                    cv.adaptiveThreshold(gray, finalMat, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 12);
                    gray.delete();
                } else { warped.copyTo(finalMat); }
                cv.imshow(previewCanvas, finalMat);
                srcCorners.delete(); destCorners.delete(); M.delete(); warped.delete(); finalMat.delete();
                showLoader(false);
            }, 50);
        };
        
        const addPageToDocument = () => {
            scannedPages.push(previewCanvas.toDataURL('image/jpeg', 0.9));
            renderThumbnails();
            closePreview();
        };

        const renderThumbnails = () => {
            pagesContainer.innerHTML = '';
            scannedPages.forEach((imageDataUrl, index) => {
                const thumbnail = document.createElement('div');
                thumbnail.className = 'page-thumbnail';
                thumbnail.innerHTML = `<img src="${imageDataUrl}" alt="Page ${index + 1}"><button class="delete-btn" data-index="${index}">Ã—</button>`;
                thumbnail.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    scannedPages.splice(parseInt(e.target.dataset.index), 1);
                    renderThumbnails();
                });
                pagesContainer.appendChild(thumbnail);
            });
            updatePdfButtonState();
        };

        const closePreview = () => {
            previewModal.style.display = 'none';
            if (originalCapturedMat && !originalCapturedMat.isDeleted()) originalCapturedMat.delete();
            originalCapturedMat = null;
        };
        
        const generatePdf = async () => {
            if (scannedPages.length === 0) return;
            showLoader(true);
            await new Promise(resolve => setTimeout(resolve, 100));
            try {
                const doc = new jsPDF();
                for (let i = 0; i < scannedPages.length; i++) {
                    const img = new Image();
                    img.src = scannedPages[i];
                    await new Promise(resolve => {
                        img.onload = () => {
                            const { width: pdfW, height: pdfH } = doc.internal.pageSize;
                            const ratio = Math.min(pdfW / img.width, pdfH / img.height);
                            const w = img.width * ratio; const h = img.height * ratio;
                            if (i > 0) doc.addPage();
                            doc.addImage(scannedPages[i], 'JPEG', (pdfW - w) / 2, (pdfH - h) / 2, w, h);
                            resolve();
                        };
                    });
                }
                const pdfOutput = doc.output('datauristring');
                const fileName = `Scan_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.pdf`;
                if (window.Android && typeof window.Android.savePdf === 'function') {
                    window.Android.savePdf(pdfOutput, fileName);
                } else {
                    console.warn('Android interface not found. Offering download fallback.');
                    const link = document.createElement('a');
                    link.href = pdfOutput;
                    link.download = fileName;
                    link.click();
                }
            } catch(e) { console.error("PDF Error:", e); alert('Error generating PDF.'); }
            finally { showLoader(false); }
        };

        startScanBtn.addEventListener('click', startCamera);
        closeScannerBtn.addEventListener('click', stopCamera);
        captureBtn.addEventListener('click', captureAndProcess);
        filterBtns.forEach(btn => btn.addEventListener('click', (e) => {
            filterBtns.forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            applyFilter(e.target.dataset.filter);
        }));
        addPageBtn.addEventListener('click', addPageToDocument);
        discardPageBtn.addEventListener('click', closePreview);
        generatePdfBtn.addEventListener('click', generatePdf);
    });
    </script>
</body>
</html>
